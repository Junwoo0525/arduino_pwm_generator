// SSD1315 1.3 inch

#include <Arduino.h>
#include <U8g2lib.h>

#ifdef U8X8_HAVE_HW_SPI
#include <SPI.h>
#endif
#ifdef U8X8_HAVE_HW_I2C
#include <Wire.h>
#endif

U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, /* clock=*/ SCL, /* data=*/ SDA, /* reset=*/ U8X8_PIN_NONE);



#define CLK 2    // 2번핀을 CLK에 연결
#define DT 3     // 3번핀을 DT에 연결


int counter = 0;   // 카운팅 저장용 변수
int currentStateCLK;     // 현재 CLK의 상태 저장용 변수
int lastStateCLK;         // 이전 CLK의 상태 저장용 변수
String currentDir = "";    // 현재 방향 출력용 문자열 변수

int sw = 4;
int mode = 0;


int32_t frequency = 240; //frequency (in Hz)

//PWM
#include <PWM.h>
int pwm = 9;
int pwmdutyper = 0;

//ON&OFF
bool out = false;


//logo
const unsigned char angchicken [] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x1e, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x06, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x02, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0xc0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x60, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x38, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0xfc, 0x39, 0x20, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0xfc, 0x39, 0x20, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0xc0, 0x07, 0x00, 0xfc, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x03, 0x00, 0xfe, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x7c, 0x02, 0x00, 0xfe, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0xff, 0x01, 0x00, 0xfe, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0x81, 0x03, 0xfe, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0x81, 0x03, 0xfe, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xc6, 0x03, 0x7f, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xc3, 0x9c, 0x03, 0x1f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0x08, 0x3d, 0x80, 0x1f, 0x30, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x7e, 0x41, 0x7a, 0x80, 0x0f, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x9e, 0x80, 0x66, 0xc0, 0x8f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x9e, 0x80, 0x66, 0xc0, 0x8f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x9e, 0x00, 0x44, 0xc0, 0x8f, 0x0f, 0xfe, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x9e, 0x00, 0x3c, 0xe7, 0x83, 0x03, 0xfe, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x7f, 0x9f, 0x80, 0xbe, 0xc6, 0x03, 0x00, 0x30, 0xfc, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x7f, 0x1f, 0x81, 0xbe, 0xc4, 0x01, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0x3e, 0xbf, 0x18, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0x3e, 0xbf, 0x18, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x81, 0x3f, 0x20, 0x10, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x7f, 0xf9, 0xff, 0x5f, 0xe0, 0x1f, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x1f, 0xf4, 0xff, 0x5f, 0xc0, 0x0f, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x1f, 0xe8, 0xff, 0x23, 0x80, 0x0f, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x1f, 0xe8, 0xff, 0x23, 0x80, 0x0f, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x0f, 0x90, 0x7f, 0x00, 0x80, 0x0f, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x07, 0x60, 0x02, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x01, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0e, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x3f, 0x00, 0x80, 0x01, 0x00, 0x00, 0x1c, 0x00, 0x00, 0xf3, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x3f, 0x00, 0x80, 0x01, 0x00, 0x00, 0x1c, 0x00, 0x00, 0xf3, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x3f, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x1f, 0x18, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x02, 0x00, 0x00, 0xf0, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x06, 0x00, 0x00, 0xe0, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x04, 0x00, 0x00, 0x20, 0xc0, 0xc1, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x04, 0x00, 0x00, 0x20, 0xc0, 0xc1, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x07, 0x00, 0xfe, 0x0f, 0x40, 0x00, 0x00, 0xe0, 0xe1, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x07, 0xfe, 0xff, 0x3f, 0xc0, 0x00, 0x40, 0xe0, 0xf7, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x01, 0x7e, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff


};

void setup() {

  // 엔코더 핀 입력으로 설정
  pinMode(CLK, INPUT);
  pinMode(DT, INPUT);
  pinMode(sw, INPUT);

  InitTimersSafe();
  bool success = SetPinFrequencySafe(pwm, frequency);
  if (success) {
    pinMode(13, OUTPUT);
    digitalWrite(13, HIGH);
  }

  // 시리얼 출력 개시
  Serial.begin(9600);
  u8g2.begin();

  // CLK핀의 최초 상태 저장
  lastStateCLK = digitalRead(CLK);

  //외부 인터럽트 등록, 핀의 상태가 변할 때(HIGH에서 LOW 또는 LOW에서 HIGH) 마다 updateEncoder함수가 실행됨.
  // 인터럽트 0번은 2번핀과 연결되어 있고 1번은 3번 핀과 연결되어 있음
  attachInterrupt(0, updateEncoder, CHANGE);
  attachInterrupt(1, updateEncoder, CHANGE);

  //OLED
  /*u8g2.setFont(u8g_font_unifont);
    u8g2.setFont(u8g2_font_6x10_tf);
    u8g2.setColorIndex(1);
  */
  u8g2_prepare();
  u8g2.setFont(u8g2_font_t0_12b_mf);
  u8g2.setColorIndex(1);

  //
  logoRun();
  delay(3000);
  u8g2.clearBuffer();
  delay(500);
  oledRun();
}

void loop() {
  




  if (digitalRead(sw) == LOW) {
    if (out == false) {
      setduty(pwmdutyper);
      oledRun();
      out = true;
      Serial.print("ON & duty : ");
      Serial.println(pwmdutyper);

    }
    else {
      setduty(0);
      oledRun();
      out = false;
      Serial.println("OFF");
    }
    while (1) {
      if (digitalRead(sw) == HIGH)
        break;
    }
  }

}

//OLED 기본 세팅

void u8g2_prepare(void) {
  u8g2.setFont(u8g2_font_7x14_tf);
  u8g2.setFontRefHeightExtendedText();
  u8g2.setDrawColor(1);
  u8g2.setFontPosTop();
  u8g2.setFontDirection(0);
}

int setduty(int dutyper) {
  int duty = map(dutyper, 0, 100, 0, 255);
  pwmWrite(pwm, duty);
}


void updateEncoder() {  // 인터럽트 발생시 실행되는 함수
  // CLK의 현재 상태를 읽어서
  currentStateCLK = digitalRead(CLK);

  // CLK핀의 신호가 바뀌었고(즉, 로터리엔코더의 회전이 발생했했고), 그 상태가 HIGH이면(최소 회전단위의 회전이 발생했다면)
  if (currentStateCLK != lastStateCLK  && currentStateCLK == 1) {

    // DT핀의 신호를 확인해서 엔코더의 회전 방향을 확인함.
    if (digitalRead(DT) != currentStateCLK) {    // 신호가 다르다면 시계방향 회전
      counter ++;                                // 카운팅 용 숫자 1 증가
      if (out == false) {
        if (mode >= 4) mode = 0;
        else mode++;
        Serial.println(mode);
        pwmMode();
        oledRun();
      }
      currentDir = "시계방향 회전";
    } else {                                   // 신호가 같다면 반시계방향 회전
      counter --;                              // 카운팅 용 숫자 1 감소
      if (out == false) {
        if (mode == 0) mode = 4;
        else mode--;
        Serial.println(mode);
        pwmMode();
        oledRun();
      }
      currentDir = "반시계 방향 회전";
    }

    //    Serial.print("회전방향: ");
    //    Serial.print(currentDir);               // 회전방향 출력
    //    Serial.print(" | Counter: ");
    //    Serial.println(counter);              // 카운팅 출력
  }

  // 마지막 상태 변수 저장
  lastStateCLK = currentStateCLK;
}

//OLED문자 출력 함수

void oledRun() {
  u8g2.firstPage();
  do {
    draw();
  } while ( u8g2.nextPage() );
  delay(10);
}

void pwmMode() {
  switch (mode) {
    case 0:
      pwmdutyper = 0;
      break;
    case 1:
      pwmdutyper = 25;
      break;
    case 2:
      pwmdutyper = 50;
      break;
    case 3:
      pwmdutyper = 75;
      break;
    case 4:
      pwmdutyper = 100;
      break;
  }
}

void draw()
{
  //Frequencyh
  u8g2.drawStr( 0, 5, "Hz :");
  u8g2.setCursor(60, 5);
  u8g2.print(frequency);
  //u8g2.sendBuffer();

  //DUTY
  u8g2.drawStr(0, 27, "Duty :");
  u8g2.setCursor(60, 25);
  u8g2.print(pwmdutyper);
  //u8g2.sendBuffer();
  //ON/OFF
  u8g2.drawStr(0, 49, "OUTPUT : ");
  if (out == 0) {
    u8g2.drawStr(60, 49, "OFF");
    //u8g2.sendBuffer();

  }
  else if (out == 1) {
    u8g2.drawStr(60, 50, "ON");
    //u8g2.sendBuffer();

  }

}

//LOGO RUN
void logoRun() {
  u8g2.firstPage();
  do {
    u8g2.drawXBMP(0, 0, 128, 64, angchicken);
  } while ( u8g2.nextPage() );
}
